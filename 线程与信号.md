##### 线程和信号
每个线程都有自己的信号屏蔽字，但信号处理是进程中所有线程所共享的。这意味着单个线程可以屏蔽某些信号，但当某个子线程修改了某个给定信号相关的处理行为后，其他线程就必须共享这个处理行为的改变。这样，如果一个线程选择忽略某，呢么其他线程就可以通过以下两种方式撤销上述线程的信号选择：恢复默认信号处理动作，或者为该信号设置一个新的信号处理程序。

进程中的信号是递送到单个线程中的。如果一个信号与硬件故障相关，呢么这个信号回发送到引起该事件的线程中去。而其他信号一般会被发送到任意线程。

在进程中我们需要用 sigprocmask 来阻塞某一信号的发送，线程中我们必须使用 pthread_sigmask 函数。

```c
#include <signal.h>

       int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
       //成功返回 0 否则返回错误编号
```
pthread_sigmask 函数与 sigprocmask 函数基本想同，不过 pthread_sigmask 工作在线程中，而且失败时返回错误码，而 sigprocmask 失败后设置 errno 并且返回 -1，set 参数是需要修改的参数集，oldset 返回线程之前的信号屏蔽字。
线程可以调用 sigwait 等待一个或多个信号出现。
```c
       #include <signal.h>

        int sigwait(const sigset_t *set, int *sig);
	//成功返回 0 否则返回错误号
```
set 指定线程等待的信号集，sig 指向的整数包含发送信号的数量。
如果在调用 sigwait 之前某个信号就处于挂起状态，呢么 sigwait 将直接返回，返回之前，

sigwait 将从进程中移除那些处于挂起等待的信号。
线程再调用 sigwait 之前必须要阻塞那些正在等待的信号。sigwait 函数会原子地取消信号集的阻塞状态（即不会让取消之后，等待之前产生信号），知道有新的信号被递送。在返回之前，sigwait 会恢复线程信号屏蔽字。

使用 sigwait 的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。为了防止信号中断线程，可以把信号加到每个县成的信号屏蔽字中，然后安排专用线程处理这些信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用哪些函数是安全的。这些函数调用来自正常的线程上下文，而并不是那些会中断线程正常执行的传统信号处理程序。

当多个线程调用 sigwait 等待同一个信号时，呢么在信号递送时只能有一个线程可以从 sigwait 中返回，如果一个信号被捕获（例如进程中通过 sigaction 建立了一个信号处理程序），而在一个线程中正在使用 sigwait 等待该信号，呢么由操作系统决定以何种方式递送信号，但两者不会同时发生。
[示例代码](https://github.com/Jastry/Blog/blob/master/IPC/signal/signal.c)
要把信号发送给进程可以调用 kill，要把信号发送给线程需要 pthread_kill
```c
       #include <signal.h>

       int pthread_kill(pthread_t thread, int sig);
       //成功返回0，否则返回错误编号
```
可以传递一个 0 值的 sig 来检查线程是否存在。如果信号的默认动作是终止该线程，呢么信号传递给某个线程仍然会杀死整个进程。
