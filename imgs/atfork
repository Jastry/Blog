##### 线程和进程
当一个多线程程序调用了 fork 函数，呢么新创建的子进程是否将自动创建和父进程相同数量的线程呢？答案是“否”，被创建出来的子进程只有一个执行线程，<font color=#00ff00>它是调用 fork 的那个线程的完整复制，并且子进程会自动继承父进程的互斥量（条件变量与之类似）的状态</font>。也就是说，也就是说父进程已经被加锁的互斥量在子进程中也是被锁住的。这就引起了一个问题：子进程并不清除从父进程继承而来的互斥量的具体状态（加锁还是解锁状态）。这个互斥量可能被加锁了，但并不是由于调用 fork 函数的哪个线程锁住的，而是由于其他线程锁住的。这样会造成子进程若再次对该互斥锁执行加锁操作就会导致死锁。
[示例代码]()
![](imgs/20180122-091939.png)
我们让父进程首先创建一个线程，主线程 sleep 1 秒保证子线程先走，子线程将锁锁住后 sleep 5s 保证在锁住的状态父进程执行了 fork 此时子进程的互斥量就处于锁住的状态了，子进程再次想要锁住互斥量的话，就会产生死锁。
![](/home/blb/work/Blog/imgs/atfork.png) 
不过 pthread 提供了一个专门的函数 pthread_atfork，以确保 fork 调用后父进程和子进程都知道当前条件变量的状态（锁了还是没锁），函数定义如下：
```c
	#include <pthread.h>
	int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
	//成功返回 0，失败返回错误码
```
该函数建立 3 个 fork 句柄来帮助我们清理互斥锁的状态。prepare 句柄将在 fork 调用创建出子进程之前被执行。它可以用来锁住所有父进程创建的互斥锁。parent 句柄则是 fork 调用创建出自进程后，而在 fork 返回之前，在父进程中被执行。它的作用是释放所有在 prepare 中锁住的互斥量。child 句柄是在 fork 返回之前，在子进程中被执行。和 parent 句柄一样，也是释放所有  prepare 中锁住的互斥量。
![](/home/blb/work/Blog/imgs/atfork2.png)
加入 pthread_atfork 后，子进程不会有死锁问题
将示例代码的 pthread_atfork 放出来
![](imgs/20180122-095242.png)